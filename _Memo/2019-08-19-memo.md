---
layout: post
title: PyCon Korea 2019 후기 - 첫째날
bigimg: /img/title_img/201908.jpg
---

### 정적 타입 검사로 더 나은 Python 코드 작성하기
* 정적 타입 언어
    * 컴파일할 때 객체의 타입이 결정됨
    * 한 번 객체의 타입이 정해지면 다른 타입으로 바뀔 수 없음
    * 코드를 작성할 때나 컴파일할 때 발생하는 타입 오류를 알 수 있어 수정 가능
* 동적 타입 언어
    * 파이썬이 이에 해당됨
    * 타입이 실행시간에 결정됨
    * 객체의 타입이 런타임에 동적으로 결정되기 때문에 유연하지만 실행시간에 예상치 못한 버그가 발생할 수 있음
* 프로젝트가 커질 수록 개발자가 많아지고 버그가 많아짐
    * 동작 타입 언어로 작성한 코드는 프로젝트가 커질수록 각 객체가 어떤 값을 알고 있는지 힘들어짐
    * 이 문제를 해결하기 위해 정적 타입 검사기를 도입
        * 동적 타입 언어를 정적 타입 언어처럼 검사해서 테스트나 실행 전에 버그를 발견할 수 있음
        * 코드의 가독성이 올라가고 타입으로 발생할 수 있는 버그를 예방해줌
* 파이썬은 버전이 올라가면서 객체에 타입을 줄 수 있는 타입 힌팅을 추가해나감
    * Function Annotation (Python 3.0+)
    * Type Annotation (Python 3.5+)
    * Variable Annotation (Python 3.6+)
* 타입 힌팅

```python
age: int = 1234 # 변수의 타입 지정

# 함수의 인자 타입, 리턴 타입 지정
def cancat_list(x: list, y: list) -> list:
    return x + y
```

* 직접 만든 class도 타입 힌팅 가능

```python
class Person(object):
    name: str
    age: int
    # ...

def is_save_person(x: Person, y: Person) -> bool:
    return x == y
```

* Python 3.5에 추가된 typing 모듈을 사용해 자세한 타입 힌팅 가능

```python
from typing import List, Tuple, Dict, Union, Optional

# 문자열만 허용하는 리스트
str_list: List[str] = ['A', 'B', 'C']

# 문자열, 정수, 부울 순서로 된 튜플
user_tuple: Tuple[str, int, bool] = ('Name', 24, True)

# 문자열 key와 실수형 value를 가진 딕셔너리
progress_dict: Dict[str, float] = {
    'Task 1': 100,
    'Task 2': 70.24,
    'Task 3': 91.1234
}

# 여러 개의 타입을 하나의 타입으로 묶기
# 문자열과 정수만 허용하는 리스트
my_list: List[Union[str, int]] = []

# 파이썬의 nullable 타입은 None
# 문자열과 None만 허용하는 리스트
my_list1: List[Union[str, None]] = []
my_list2: List[Optional[str]] = []
```

* 만약 같은 타입을 여러 번 사용해야하는 경우 typing 모듈의 NewType 함수를 사용하여 코드를 줄일 수 있음

```python
from typing import List, Union

my_numeric_list: List[Union[int, float]] = []
other_numeric_list: List[Union[int, float]] = []
another_numeric_list: List[Union[int, float]] = []
```
```python
from typing import List, Union, NewType

numeric = NewType('numeric', Union[int, float])
NumericList = NewType('NumericList', List[numeric])

my_numeric_list: NumericList = []
other_numeric_list: NumericList = []
another_numeric_list: NumericList = []
```

* 제네릭
    * 제네릭 클래스는 typing의 Generic이라는 베이스 클래스를 상속받아 구현 가능

```python
from typing import TypeVar, Sequence

# TypeVar가 선언한 T가 제네릭을 나타냄
T = TypeVar('T')
# 제네릭에서 허용하는 타입만 제한할 경우
# int 혹은 float으로 이루어진 Sequence만 인자로 받음
T = TypeVar('T', int, float) 

# 리스트, 튜플, 스트링 같은 자료형의 컨테이너인 Sequence 타입을 인자로 받고
# 첫번째 요소를 받환해주는 제네릭 함수
def first(s: Sequence[T]) -> T:
    return s[0]
```

* 함수를 위한 타입 힌팅

```python
from typing import Callable

def sum_to_str(x: int, y: int) -> str:
    return str(x + y)

# 첫번째 인자 : 값으로 받을 함수의 파라미터의 타입 목록
# 두번째 인자 : 값으로 받을 함수의 반환 타입
f: Callable[[int, int], str] = sum_to_str

#output
f(10, 20)
>>> "30"
```

* 비동기 함수로 지원함

```python
import asyncio

async def wait(sec: int) -> str:
    for i in range(sec):
        await asyncio.sleep(1)

    return f"{sec} second(s) elapsed"
```

* 명시된 타입과 들어오는 타입이 다를 경우
    * 잘 작동함
    * typing 모듈은 이 변수가 이 타입일 것이라고 알려주기만 할 뿐 제한하지 않음
    * `my[py]`이라는 정적 타입 검사기를 통해 오류를 보여줌
        * `$ pip install mypy`로 설치 가능
        * `$ mypy [files and directories...]` : 검사할 파일이나 폴더 목록을 인자로 넘겨줌
        * `$ mypy my_app.py my_src` : 하나의 파일과 폴더 통째로 검사할 때

```python
from typing import List

i: int = 'abcd'
>>> "abdc"

l: List[str] = [1, 2, 3]
>>> [1, 2, 3]
```
```python
# mypy는 처음 대입된 값의 타입을 그 객체의 타입으로 보기 때문에 아래는 오류를 뱉어냄

x = 1       # typed as int
x = 'abcd'  # ERROR!
```
```python
# 기존 파이썬처럼 객체에 동적인 타입을 부여하고 싶다면 Any으로 타입 힌팅
from typing import Any

x: Any = 1  # dynamically typed
x = 'abcd'  # OK
```

### 하나의 Django 코드로 여러 사이트 운영하기


[정적 타입 검사로 더 나은 Python 코드 작성하기 - 이창희 - PyCon.KR 2019](https://www.youtube.com/watch?v=KWjGj_0lPro)
[하나의 Django 코드로 여러 사이트 운영하기 - 박종현 - PyCon.KR 2019](https://www.youtube.com/watch?v=b2BFxbkXkKY)